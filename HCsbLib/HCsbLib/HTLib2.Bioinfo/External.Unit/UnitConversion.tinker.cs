using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HTLib2.Bioinfo
{
	public partial class UnitConversion
	{
        static readonly double freq_convert     = 4.1840     * 100;
        static readonly double freq_lightspd    = 2.99792458 / 100;
        static readonly double freq_factor      = Math.Sqrt(freq_convert) / (2.0 * Math.PI * freq_lightspd);

        public static double EigvalToFreq(double eigval)
        {
            {
                /// Discussion
                /// https://www.charmm.org/ubbthreads/ubbthreads.php?ubb=showflat&Number=32622
                /// 
                /// =============================================================================================================
                /// Frequencies from Quasiharmonic Analysis 
                /// =============================================================================================================
                /// slaw :  Hi CHARMM Community,
                ///         
                ///         I am trying to understand the output produced from quasiharmonic analysis but I am getting stuck
                ///         on something that seems minor to me. I have calculated the variance/covariance matrix from a
                ///         simulation trajectory, diagonalized the matrix, and obtained the eigenvalues and eigenvectors
                ///         using CHARMM. 
                ///         
                ///         The first thing that I noticed was that the eigenvalues reported in the CHARMM output was different
                ///         from the eigenvalues that are generated by the variance/covariance matrix. After going through the
                ///         JCP 2001 paper, I realized that CHARMM was not outputting the eigenvalues from the variance/covariance
                ///         matrix and, instead, was outputting a scaled eigenvalue (scaled by kT/eigenvalue).
                ///         
                ///         Next, I examined the frequencies output by CHARMM and compared them with frequencies that I calculated
                ///         directly from the scaled eigenvalues. According to the JCP paper, the frequencies, w, are calculated from
                ///         
                ///         w[i] = sqrt(kT/lambda[i])
                ///         
                ///         where lambda are the unscaled eigenvalues from the variance/covariance matrix. According to the
                ///         CHARMM documentation, the frequency is expressed in units of cm^-1 so I tried playing around with
                ///         the unit conversions. It took me a while to remember that lambda[i] were in units of
                ///         mass*Angstroms*Angstroms (and not simply Angstroms*Angstroms) since the matrix is mass weighted.
                ///         Realizing this, then the frequencies, w[i], would result in units of inverse seconds (or Hz). 
                ///         
                ///         Here is where I am having some problem with the final conversion. Normally, to convert the frequencies
                ///         into units cm^-1, one simply divides the frequencies by the speed of light (c = 2.99 x 10^8 m/s):
                ///         
                ///         Frequency[i] = w[i]/c
                ///         
                ///         However, this did not suffice to recapituate the frequencies reported by CHARMM. Instead, I found
                ///         that CHARMM is multiplying the frequencies, w[i], by:
                ///         
                ///         Frequency[i] = (2045.5/(2.99793*6.28319)) * w[i]
                ///         
                ///         I can see that the 2.99793 corresponds to the speed of light (although I don't see where the 10^8
                ///         disappeared to) and the 6.28319 corresponds to 2*Pi. However, I have no idea where the 2045.5 comes
                ///         from (I see that it is somehow related to sqrt(cal) = sqrt(4.814 J) but it isn't clear to me why
                ///         it is needed and why the value is so large).
                ///         
                ///         I would appreciate any clarification on the following:
                ///         
                ///         1) Where the "10^8" disappeared to
                ///         2) Why are we dividing by 2*Pi
                ///         3) Where does the 2045.5 come from
                ///         
                ///         Thanks in advance!
                /// =============================================================================================================
                /// lennart :
                ///         CHARMM does not use SI-units; usage.doc. 2*Pi to convert to/from angular frequency.
                ///         _________________________
                ///         Lennart Nilsson
                ///         Karolinska Institutet
                ///         Stockholm, Sweden
                /// =============================================================================================================
            }
            {
                /// A part of the original manuscript of universal paper.
                /// ================================================================
                /// \begin{equation} 
                ///  \label{eqn:eig2freq} 
                ///  \omega_i = \frac{1}{2 \pi c} \sqrt{d\,\lambda_i}, 
                ///  \end{equation} 
                ///  % 
                ///  %http://users.mccammon.ucsd.edu/~dzhang/energy-unit-conv-table.html 
                ///  where $c$ is the speed of light in vaccum whose value is $2.997925\times 10^{-2}\,[\mbox{cm/ps}]$, and
                ///  $d$ is the conversion constant from {{kcal/mol}} to {{J/mol}} whose value is
                ///  $4.184\times10^{2}\,[\mbox{g}\mbox{\AA}^2/\mbox{ps}^2/\mbox{kcal}]$;
                /// ================================================================
            }
            {
                /// tinker-6.2.06: units.i
                ///     convert     conversion from kcal to g*Ang**2/ps**2
                ///     lightspd    speed of light in vacuum (c) in cm/ps
                ///     convert =4.1840d+2
                ///     lightspd=2.99792458d-2
                /// 
                /// tinker-6.2.06: vibrate.f
                ///      call diagq (nfreq,nfreq,matrix,eigen,vects)
                ///      factor = sqrt(convert) / (2.0d0*pi*lightspd)
                ///      do i = 1, nvib
                ///         eigen(i) = factor * sign(1.0d0,eigen(i)) * sqrt(abs(eigen(i)))
                ///      end do
                ///      write (iout,30)
                ///   30 format (/,' Vibrational Frequencies (cm-1) :',/)
                ///      write (iout,40)  (i,eigen(i),i=1,nvib)
                ///   40 format (5(i5,f10.3))
                /// 
                /// vibrate frequency (cm^-1) = factor * sign(eigen(i)) * sqrt(abs(eigen(i)))
                ///                           = sign(eigen(i)) * sqrt(abs(eigen(i))) * factor
                ///                           = sign(eigen(i)) * sqrt(abs(eigen(i))) * (sqrt(convert) / (2 * pi * lightspd))
                double freq = Math.Sign(eigval) * Math.Sqrt(Math.Abs(eigval)) * freq_factor;
                return freq;
            }
        }
        public static double FreqToEigval(double freq)
        {
            double eigval = Math.Sign(freq) * (freq*freq) / (freq_factor*freq_factor);
            if(HDebug.IsDebuggerAttached)
            {
                double _freq = EigvalToFreq(eigval);
                double _diff = freq - _freq;
                HDebug.Assert(Math.Abs(_diff) < 0.00000001);
            }
            return eigval;
        }
    }
}
